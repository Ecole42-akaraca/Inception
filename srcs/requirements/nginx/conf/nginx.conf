# https://www.nginx.com/resources/wiki/start/topics/examples/full/
# https://www.coderrocketfuel.com/article/default-nginx-configuration-file-inside-sites-available-default
# https://wordpress.org/documentation/article/nginx/
# https://www.hafifbilgiler.com/hafif-bilgiler/yazilim/linux/liniux-uzerinde-nginx-kurulumu/

server {
	# 'listen 443 ssl;' ifadesi, Nginx'in 443 numaralı bağlantı noktasından gelen SSL/TLS şifrelemeli istekleri dinlemesi gerektiğini ifade eder.
	#	SSL/TLS şifrelemesi, iletişimi şifrelemek ve güvenli hale getirmek için kullanılır.
	#	443 numalaralı bağlantı noktası, genellikle HTTPS protokolü tarafından kullanılır.
	#  Eğerki 'listen 443;' şeklinde kullanılsaydı, belirtilen bağlantı noktası üzerinden gelen istekler şifrelenmez.
	#	Yani bu şekilde kullanıldığında, Nginx'in güvenli bir HTTPS bağlantısı sağlamak için SSL/TLS şifrelemesi kullanmaz.
	#	Eğer kullanıcılardan hassas bilgilerin toplandığı, güvenliği önemli olan bir web sitesi veya uygulamanız varsa, HTTPS üzerinden güvenli iletişim sağlamak önemlidir.
	#	HTTPS kullanımı, özellikle güvenlik ve veri gizliliği önemli olan web siteleri için şiddetle tavsiye edilir.
	listen 443 ssl;

	# 'listen [::]443 ssl;' ifadesi, Nginx'in IPv6 desteğini aktif ettiğini ve yine 443 numaralı bağlantı noktasından gelen SSL/TLS şifrelemeli istekleri IPv6 üzerinden de dinlemesi gerektiğini ifade eder.
	# !!! Subjectte IPv6 için atıfta bulunmadığı için gerek olmayabilir.
	listen [::]:443 ssl;

	# 'server_name akaraca.42.fr;' ifadesi, Nginx'in hangi ana bilgisayar adı veya alan adı ile gelen istekleri yönlendirmesi gerektiğini belirtir.
	#	'server_name' direktifi, sunucunun hangi istemcileri dinleyeceğini belirler.
	#	Bu, Nginx'in gelen istekleri hangi alan adına veya ana bilgisayar adına göre eşleştireceğini belirlemek için kullanılır.
	server_name akaraca.42.fr test.42.fr;

	# Sertifikasyon dosyalarının oluşturulması için nginx.sh'ın çalıştırılması gerekmektedir.
	# 'ssl_protocols TLSv1.2 TLSv1.3;' ifadesi, Nginx'in desteklediği SSL/TLS protokollerini belirtmek için kullanılır.
	# 'ssl_protocols' direktifi, sunucunun hangi SSL/TLS protokollerini kabul edeceğini belirler.
	#	Birden fazla protokol atanabilir, örneğin TLSv1.2 TLSv1.3 ...
	#	Bu şekilde Nginx'in yalnızca TLSv1.2 ve TLSv1.3 protokollerini kabul edeceği anlamına gelir.
	#	Eski ve güvensiz SSL/TLS sürümleri (örneğin, TLSv1.0 TLSv1.1) bu konfigürasyonda devre dışı bırakılır.
	ssl_protocols TLSv1.2 TLSv1.3;

	# 'ssl_certificate /etc/ssl/certs/nginx.crt;' ifadesi, Nginx'in kullanacağı SSL sertifikasının dosya yolunu belirtir.
	#	SSL, sertifikaları, web sunucularının güvenli HTTPS bağlantıları sağlamak için kullandığı dijital sertifikalardır.
	# 'ssl_certificate' direktifi, Nginx'in genel anahtar altyapısını (Public Key Infrastructure - PKI) ile imzalanan sertifika dosyasının yolunu tanımlar.
	# Bu sertifika, web sitesinin gerçekliğini doğrulayan bir üçüncü taraf (CA - Certificate Authority) tarafından imzalanır ve ana bilgisayarın kimliğini doğrulamak için kullanılır.
	#	Web sunucusunun TLS(Transport Layer Security) bağlantılarında kullanılacak ve tarayıcılardan gelen istemcilere güvenli bir şekilde iletişim kurulmasını sağlayacaktır.
	ssl_certificate /etc/ssl/certs/nginx.crt;

	# 'ssl_certificate_key /etc/ssl/private/nginx.key;' ifadesi, Nginx'in kullanacağı SSL sertifikasının özel anahtarının dosya yolunu belirtir.
	#	SSL/TLS bağlantıları güvenli hale getirmek için kullanılan sertifikalar, asimetrik kriptografi temelinde çalışır ve bir çift anahtardan oluşur: özel anahtar(private key) ve genel anahtar(public key)
	#	Özel anahtar, SSL/TLS bağlantısını başlatan sunucunun gizli anahtarıdır ve yalnızca sunucuda saklanır.
	#	Bu anahtar, şifrelenmiş verileri çözmek ve kimlik doğrulaması yapmak için kullanılır.
	#	Özel anahtar, yalnızca sunucu tarafından bilinir ve güvenli bir şekilde saklanmalıdır.
	#	Nginx tarafından SSL/TLS bağlantılarında kullanılır ve sertifika doğrulaması ve şifreleme işlemleri için kullanılır.
	#	Web sunucusunun güvenli bağlantılar kurmak ve verileri şifrelemek için kullanılır.
	ssl_certificate_key /etc/ssl/private/nginx.key;

	# 'root' direktifi, Nginx sunucusunun istemcilere servis edeceği dosyaların kök dizinini belirtir.
	#	İstemci tarafından yapılan isteklere göre, Nginx bu belirtilen kök dizin altında bulunan dosyaları sunucudan alır ve istemciye gönderir.
	# İstemci, Nginx sunucusuna yaptığı bir istekte, 'var/www/html' dizininde bulunan dosyaları alır ve görüntüler.
	#	Bu, temel olarak web sitesi dosyalarının kök dizinini tanımlar ve kullanıcıların web sitesinin içeriğine erişebileceği yerdir.
	# İstemci, web sitelerine erişen ve sunucudan içerik talep eden kişisel bilgisayarlar, telefonlar vd. cihazlar olabilir.
	root /var/www/html;

	# 'index index.html' ifadesi, Nginx sunucusunun kök dizininde(root) bir istemci(web tarayıcısı) web sitesine istek yaptığında hangi dosyayı varsayılan olarak göstereceğini belirtir.
	# 'index.html', varsayılan olarak gösterilecek olan dosya adını belirtir.
	#	Yani, istemci bir klasörün içine istek yaptığında ve o klasörde 'index.html' dosyası varsa, Nginx bu dosyayı gösterecektir.
	#	Örneğin, eğer bir istemci 'server_name' direktifindeki adresine(akaraca.42.fr) istek yaparsa, Nginx kök dizinindeki 'index.html' dosyasını gösterecektir.
	# Bu yapılandırma, özellikle basit statik web sitelerinde yaygın olarak kullanılır.
	# Eğer farklı bir varsayılan dosya adı kullanmak istenirse, 'index' direktifine farklı dosya adı eklenerek belirtilir.
	#	Örneğin, 'index index.php index.html;' şeklinde belirtilirse, Nginx önce 'index.php' dosyasını arayacak, eğer bulamazsa 'index.html' dosyasını gösterecektir.	
	index index.html;

	# 'location /' bloğu, Nginx sunucusuna gelen tüm istemcilerin isteklerini ele alır.
	#	İstemciden gelen HTTP isteklerini yönlendirmek ve belirli işlemler yapmak için kullanılır.	
	#	İstemciden gelen URI'nin başlangıcına eşleşir, yani tüm istekler için geçerli olur.
	#	Bu nedenle, bu blok, sunucuya gelen tüm istekleri ele alır ve bunların nasıl işleneceğini belirler.
	#	URI, Uniform Resource Identifier'dir (Eşgüdümlü kaynak tanımlayıcısı).
	#		URI, bir kaynağa erişmek için kullanılan bir adrestir.
	location / {
	#		'uri' değişkeni, istemde bulunan dosyanın URI'sini temsil eder.
	#			Örneğin, 'http://localhost/index.html' isteminde, uri değişkeninin değeri 'index.html' olacaktır.
		try_files $uri $uri/ =404;
	}
}


#Default nginx config file: ↓
# $> sudo apt install nginx
# $> cat /etc/nginx/sites-enabled/default

# ##
# # You should look at the following URL's in order to grasp a solid understanding
# # of Nginx configuration files in order to fully unleash the power of Nginx.
# # https://www.nginx.com/resources/wiki/start/
# # https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# # https://wiki.debian.org/Nginx/DirectoryStructure
# #
# # In most cases, administrators will remove this file from sites-enabled/ and
# # leave it as reference inside of sites-available where it will continue to be
# # updated by the nginx packaging team.
# #
# # This file will automatically load configuration files provided by other
# # applications, such as Drupal or Wordpress. These applications will be made
# # available underneath a path with that package name, such as /drupal8.
# #
# # Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
# ##

# # Default server configuration
# #
# server {
#         listen 80 default_server;
#         listen [::]:80 default_server;

#         # SSL configuration
#         #
#         # listen 443 ssl default_server;
#         # listen [::]:443 ssl default_server;
#         #
#         # Note: You should disable gzip for SSL traffic.
#         # See: https://bugs.debian.org/773332
#         #
#         # Read up on ssl_ciphers to ensure a secure configuration.
#         # See: https://bugs.debian.org/765782
#         #
#         # Self signed certs generated by the ssl-cert package
#         # Don't use them in a production server!
#         #
#         # include snippets/snakeoil.conf;

#         root /var/www/html;

#         # Add index.php to the list if you are using PHP
#         index index.html index.htm index.nginx-debian.html;

#         server_name _;

#         location / {
#                 # First attempt to serve request as file, then
#                 # as directory, then fall back to displaying a 404.
#                 try_files $uri $uri/ =404;
#         }

#         # pass PHP scripts to FastCGI server
#         #
#         #location ~ \.php$ {
#         #       include snippets/fastcgi-php.conf;
#         #
#         #       # With php-fpm (or other unix sockets):
#         #       fastcgi_pass unix:/run/php/php7.4-fpm.sock;
#         #       # With php-cgi (or other tcp sockets):
#         #       fastcgi_pass 127.0.0.1:9000;
#         #}

#         # deny access to .htaccess files, if Apache's document root
#         # concurs with nginx's one
#         #
#         #location ~ /\.ht {
#         #       deny all;
#         #}
# }


# # Virtual Host configuration for example.com
# #
# # You can move that to a different file under sites-available/ and symlink that
# # to sites-enabled/ to enable it.
# #
# #server {
# #       listen 80;
# #       listen [::]:80;
# #
# #       server_name example.com;
# #
# #       root /var/www/example.com;
# #       index index.html;
# #
# #       location / {
# #               try_files $uri $uri/ =404;
# #       }
# #}